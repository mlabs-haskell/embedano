use std::{ops::Add, thread, time};

use cardano_embedded_sdk::crypto as ec;
use cardano_serialization_lib::{
    address::{Address, EnterpriseAddress, StakeCredential},
    crypto::Ed25519KeyHash,
    plutus::{PlutusData, PlutusDatumSchema},
};

use cardano_embedded_sdk::api as embedano;
use clap::{command, Parser};
use derivation_path::DerivationPath;
use device_dummy::DeviceDummy;
use node_client::{Network, NodeClient};
use serde_json::Value;

mod device_dummy;
mod node_client;
mod tx_build;
mod tx_envelope;

#[derive(Parser, Debug)]
#[command(about, long_about = None)]
struct Args {
    /// Mnemonics for HD wallet
    #[arg(long)]
    mnemonics: String,
    /// HD wallet password
    #[arg(long)]
    password: String,
    /// Address of script that will store sensor data (address should correspond to network type!)
    #[arg(long)]
    /// Derivation path for keys
    derivation_path: String,
    #[arg(long)]
    script_address: String,
    /// Network type
    #[arg(long)]
    network: Network,
    /// Path to node socket
    #[arg(long)]
    node_socket: String,
}

fn main() {
    let socket = String::from("./cardano-node.socket");
    let node_client = node_client::CliNodeClient::new(socket, Network::Preprod);

    let s_addr =
        Address::from_bech32("addr_test1wqzfvnszsq4kx82eec4smazdr8t909gp4amwt5s86z6tqjghcsqk0")
            .unwrap();

    let derivation_path: DerivationPath = "m/1852'/1815'/0'/0/0".parse().unwrap();

    let device = device_dummy::DeviceDummy::init(
        "initial label sand movie check train leaf escape hurt sort remove risk",
    );
    let pub_key = device.get_pub_key("", &derivation_path);

    let res = node_client.query_raw_inputs(&s_addr).unwrap();
    println!("RESULT: {:?}", res);

    for v in res.into_values() {
        let inline_dat = &v["inlineDatum"];
        let inline_dat = &v["inlineDatum"];
        let inline_dat = "{\"list\":[{\"int\":18063009340550085},{\"bytes\":\"0436bf52d8be51d6d54fe839ba3646d20cc959ce13a84f3ff9d36bda4629c7866a422e00ed8c31f9ac09c53423f0527675a35cf0c7342b95417c751608137b01\"}]}";
        // let json = inline_dat.as_str().unwrap();

        println!("JSON {:?}:", inline_dat);
        println!(
            "DPAt {:?}:",
            PlutusData::from_json(inline_dat, PlutusDatumSchema::DetailedSchema)
        )

        // let data = &v["inlineDatum"]["list"].as_array().unwrap();
        // let num = &data[0]["int"];
        // let num:u64 = num.as_f64().unwrap() as u64;
        // let sig = &data[1]["bytes"].as_str().unwrap();
        // println!("NUM: {:?}", num);
        // println!("SIG: {:?}", PlutusData::from_hex(sig));

        // println!("VERIFY: {:?}", pub_key.verify(&num.to_ne_bytes(), &sig))
    }

    let t_d = device.get_test_data("",&derivation_path);
    println!("Device bytes: {:?}", t_d);
    println!("Device hex: {:?}", hex::encode(&t_d));
    println!("Plutus bytes: {:?}", PlutusData::new_bytes(t_d).to_json(PlutusDatumSchema::DetailedSchema));

    // ----------------------------------------------
    // let args = Args::parse();

    // let derivation_path: DerivationPath = args
    //     .derivation_path
    //     .parse()
    //     .expect("Should parse derivation path");

    // // address of always succeeds script
    // let script_address =
    //     &Address::from_bech32(args.script_address.as_str()).expect("Should parse script address");

    // let node_client = node_client::CliNodeClient::new(args.node_socket, args.network);

    // let device = device_dummy::DeviceDummy::init(args.mnemonics.as_str());

    // // for _ in 0..5 {
    //     submit_data_to_blockchain(
    //         &node_client,
    //         &device,
    //         args.network,
    //         &script_address,
    //         args.password.as_str(),
    //         &derivation_path,
    //     );
    //     thread::sleep(time::Duration::from_secs(2))
    // // }
}

fn submit_data_to_blockchain(
    node_client: &impl NodeClient,
    device: &DeviceDummy,
    network: Network,
    script_address: &Address,
    password: &str,
    derivation_path: &DerivationPath,
) {
    let pub_key = device.get_pub_key(password, derivation_path);
    // build users wallet address from public key
    let user_wallet_address = EnterpriseAddress::new(
        translate_network(network),
        &StakeCredential::from_keyhash(
            &Ed25519KeyHash::from_hex(pub_key.hash_hex().as_str())
                .expect("Should be able to parse public key hash from hex"),
        ),
    )
    .to_address();

    // todo: throw error if inputs empty
    let (inputs, ins_total_value) = node_client
        .query_inputs(&user_wallet_address)
        .expect("Should return inputs from user address. Is node running and available?");

    let device_data = device.get_signed_sensor_data(password, derivation_path);

    // make unsigned Tx (with empty witness set) to get id
    let unsigned_tx = tx_build::make_unsigned_tx(
        &user_wallet_address,
        &script_address,
        device_data,
        &inputs,
        ins_total_value, //for balancing
        &pub_key,
    );

    let tx_id = node_client.get_tx_id(&unsigned_tx);

    println!("Tx ID: {}", tx_id.to_hex());

    let signature = device.sign_tx_id(&tx_id, password, derivation_path);

    let signed_tx = tx_build::make_signed_tx(&unsigned_tx, &pub_key, signature.to_bytes());

    let submit_result = node_client.submit_tx(&signed_tx);
    println!("Submission result: {:?}", submit_result)
}

fn translate_network(net: Network) -> u8 {
    match net {
        Network::Mainnet => 1,
        Network::Preprod => 0,
    }
}
